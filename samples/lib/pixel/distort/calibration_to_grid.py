# Adapted from OpenCV tutorial
# https://docs.opencv.org/3.4/dc/dbb/tutorial_py_calibration.html

import os
import sys

import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np

if len(sys.argv) != 2:
    print('usage: ' + sys.argv[0] + ' path/to/file.jpg')
    sys.exit(1)
basename = os.path.splitext(sys.argv[1])[0]

# Get the input image resolution
img = cv.imread(sys.argv[1])
img_h, img_w = img.shape[:2]

# Load the correction coefficients from the previous script, or any other source
matrix = np.loadtxt(basename + '.matrix.txt')
dist = np.loadtxt(basename + '.dist.txt')

# Compute the coefficients
new_matrix, roi = cv.getOptimalNewCameraMatrix(matrix, dist, (img_w, img_h), 1, (img_w, img_h))
map_x, map_y = cv.initUndistortRectifyMap(matrix, dist, None, new_matrix, (img_w, img_h), 5)
dst = cv.remap(img, map_x, map_y, cv.INTER_LINEAR)

assert len(map_x) == len(map_y)

# Print the result as a NX * NY grid
num_x = 8  # Number of values on the horizontal axis
num_y = 8  # Number of values on the vertical axis

# Margin in pixel to avaoid over-stretched regions on the edges
margin_top = 20
margin_left = 40
margin_right = 20
margin_bottom = 40

# Generate a C source header
print('/*')
print(' * Copyright The Zephyr Project Contributors')
print(' * SPDX-License-Identifier: Apache-2.0')
print(' * Generated by calibration_to_grid.py')
print(' */')
print('')
print('#include <stdint.h>')
print('')
print(f'static const uint16_t distort_input_width = {img_w};')
print(f'static const uint16_t distort_input_height = {img_h};')
print('')
print('/* For each destination pixel, coordinates of the pixel in the source image */')
print('static const struct pixel_pt pixel_distort_grid_pts[] = {')


def print_row(row_x, row_y):
    first = True

    for x in np.linspace(margin_left, img_w - margin_right, num_x):
        if first:
            print('\t', end='')
        else:
            print(' ', end='')

        first = False

        val_x = int(row_x[int(x)])
        val_y = int(row_y[int(x)])
        print('{' + f'{val_y}, {val_x}' + '},', end='')
        plt.scatter(val_x, val_y)


# Iterate over every value of the NX * NY grid and print it in C array syntax
for y in np.linspace(margin_top, img_h - margin_bottom, num_y):
    print_row(map_x[int(y)], map_y[int(y)])

plt.savefig(basename + '.plot.png')

print('};')
print('')
print('static const struct pixel_grid pixel_distort_grid = {')
print('\t.points = pixel_distort_grid_pts,')
print(f'\t.width = {num_x},')
print(f'\t.height = {num_y},')
print('};')
